void ListDelegate::paint(QPainter *painter, const QStyleOptionViewItem &option, const QModelIndex &index) const
{
    QRect r = option.rect;

    // Цвета и кисти
    QPen linePen(QColor::fromRgb(211, 211, 211), 1, Qt::SolidLine);
    QPen lineMarkedPen(QColor::fromRgb(0, 90, 131), 1, Qt::SolidLine);
    QPen fontPen(QColor::fromRgb(51, 51, 51), 1, Qt::SolidLine);
    QPen fontMarkedPen(Qt::white, 1, Qt::SolidLine);

    // Рисуем фон
    if (option.state & QStyle::State_Selected) {
        QLinearGradient gradientSelected(r.left(), r.top(), r.left(), r.height() + r.top());
        gradientSelected.setColorAt(0.0, QColor::fromRgb(59, 158, 220));
        gradientSelected.setColorAt(1.0, QColor::fromRgb(59, 158, 220));
        painter->setBrush(gradientSelected);
        painter->drawRect(r);
        painter->setPen(fontMarkedPen);
    } else {
        painter->setBrush(QColor::fromRgb(250, 237, 241));
        painter->drawRect(r);
        painter->setPen(fontPen);
    }

    // Данные элемента
    QIcon newMsg = QIcon(":/resource/222/m_krug.png");
    QIcon statusUser = QIcon(":/resource/222/vseti.png");
    QString title = index.data(Qt::DisplayRole).toString();
    QString description = index.data(Qt::UserRole + 1).toString();
    QString date = index.data(Qt::UserRole + 2).toString();
    QString new_mes = index.data(Qt::UserRole + 3).toString();
    int status_seti = index.data(Qt::UserRole + 4).toInt();
    QString contact_photo = index.data(Qt::UserRole + 5).toString();

    // Размеры для аватара
    int imageSpace = 70;
    QRect avatarRect = option.rect.adjusted(10, 10, -option.rect.width() + 70, -10);

    // Загружаем аватарку
    QImage avatarImage;
    if (contact_photo.isEmpty()) {
        avatarImage = QImage(":/resource/222/avatar.png");
    } else {
        avatarImage = QImage(contact_photo);
    }

    // Масштабируем аватарку с сохранением пропорций
    QImage scaledAvatar = avatarImage.scaled(
        avatarRect.size(),
        Qt::KeepAspectRatio,
        Qt::SmoothTransformation
    );

    // Готовим клиппинг по кругу
    QPainterPath path;
    path.addEllipse(avatarRect);

    painter->save();
    painter->setClipPath(path);

    // Центрируем аватарку внутри круга
    QPoint center = avatarRect.center();
    QPoint topLeft(center.x() - scaledAvatar.width() / 2, center.y() - scaledAvatar.height() / 2);
    QRect targetRect(topLeft, scaledAvatar.size());

    // Рисуем аватарку
    painter->drawImage(targetRect, scaledAvatar);

    painter->restore();

    // Если есть новое сообщение, рисуем иконку
    if (!new_mes.isEmpty()) {
        QRect newMsgRect = option.rect.adjusted(409, 22, -7, -7);
        newMsg.paint(painter, newMsgRect, Qt::AlignVCenter | Qt::AlignLeft);
    }

    // Если пользователь в сети, рисуем статус
    if (status_seti == 1) {
        QRect statusRect = option.rect.adjusted(44, 44, 9, -9);
        statusUser.paint(painter, statusRect, Qt::AlignVCenter | Qt::AlignLeft);
    }

    // Заголовок
    r = option.rect.adjusted(imageSpace, 0, -10, -30);
    painter->setFont(QFont("Arial", 11, QFont::Bold));
    painter->drawText(r.left(), r.top(), r.width(), r.height(), Qt::AlignBottom | Qt::AlignLeft, title, &r);

    // Описание
    r = option.rect.adjusted(imageSpace, 30, -10, 0);
    if (description.length() > 45) {
        qreal maxWidth = std::max(150.0, option.rect.width() * 0.7);
        r.setWidth(maxWidth);
    }
    painter->setFont(QFont("Lucida Grande", 10, QFont::Normal));
    painter->drawText(r.left(), r.top(), r.width(), r.height(), Qt::AlignLeft, description, &r);

    // Дата
    r = option.rect.adjusted(402, 6, -10, 0);
    painter->setFont(QFont("Lucida Grande", 10, QFont::Normal));
    painter->drawText(r.left(), r.top(), r.width(), r.height(), Qt::AlignLeft, date, &r);

    // Новые сообщения (число)
    if (new_mes.length() < 2) {
        r = option.rect.adjusted(418, 30, -10, 0);
    } else {
        r = option.rect.adjusted(414, 30, -10, 0);
    }
    painter->setFont(QFont("Lucida Grande", 9, QFont::Normal));
    painter->drawText(r.left(), r.top(), r.width(), r.height(), Qt::AlignLeft, new_mes, &r);
}
